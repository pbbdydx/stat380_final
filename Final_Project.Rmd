---
title: "Final_Project"
author: Dylan Bauer, Prajwal Bhandari, Cameron Moore
output: html_document
---

## Front Matter

```{r}
# clear env, load libraries and data
rm(list = ls())
library(tidyverse)
library(readr)

cod_p1 <- read_csv('CODGames_p1_380.csv')
cod_p2 <- read_csv('CODGames_p2_380.csv')
gm_data <- read_csv('CODGameModes.csv')
map_data  <- read.csv('CODMaps.csv')

# we combine the results of player 1 and player 2 according to the instructions
# so first add a column to indicate which player it is in case it is used for the future problems
cod_p1$player = 1
cod_p2$player = 2

full_data <- rbind(cod_p1, cod_p2)

# lowercase column names.
# AI disclosure: We asked chatgpt 4o to modify the column names with regex
names(full_data) <- tolower(gsub("([a-z])([A-Z])", "\\1_\\2", names(full_data)))

```
### Preliminary Data Cleaning
Before we start working on any of the tasks, we should clean the full dataset thoroughly so we do not run into any issues later on.

We clean the map names for the `map1`, `map2`, `choice` columns, edit any bad vote records in the `map_vote` column, and change the `game_type` column to follow the same pattern. We use the `setdiff()` function to compare the current map names and the clean map names, which is why we have the specific cases in our `case_when` clauses. Finally, we separate the `map_vote` column so we can do task 1 effectively. Dropping columns with too many missing values may also be useful but we keep them for now.

```{r}
# get a list of the clean names
clean_maps <- as.vector(unique(map_data$Name))

clean_data <- full_data %>%
  mutate(
    map1 = case_when(
      map1 %in% clean_maps ~ map1,
      map1 %in% c('Collateral', 'Collateral Streik', 'Collaterol Strike') ~ 'Collateral Strike',
      map1 == 'Deprogam' ~ 'Deprogram',
      map1 == 'Miami Stirke' ~ 'Miami Strike',
      map1 == 'Ruah' ~ 'Rush',
      map1 == 'Riad' ~ 'Raid',
      map1 == 'Drive-in' ~ 'Drive-In'
      ),
    map2 = case_when(
      map2 %in% clean_maps ~ map2,
      map2 %in% c('Miami Stirke', 'Miami Sstrike') ~ 'Miami Strike',
      map2 == 'yamantau' ~ 'Yamantau', 
      map2 == 'Collateral' ~ 'Collateral Strike',
      map2 == 'Amrada Strike' ~ 'Armada Strike',
      map2 == 'Drive-in' ~ 'Drive-In'
      ),
    choice = case_when(
      choice %in% clean_maps ~ choice,
      choice %in% c("APocalypse","Apocolypse") ~ 'Apocalypse',
      choice %in% c('Collateral', 'Collaterel Strike') ~ 'Collateral Strike',
      choice == 'Deisel' ~ 'Diesel',
      choice == 'Drive-in' ~ 'Drive-In',
      choice == 'Riad' ~ 'Raid'
    ),
    # notice there are 'X o Y' values for the map vote so use gsub to swap them
    map_vote = gsub(' o ', ' to ', map_vote),
    # clean the game type variable since it will be used in task 3
    game_type = case_when(
      game_type == 'HC - TDM' ~ 'TDM',
      game_type == 'HC - Kill Confirmed' ~ 'Kill Confirmed',
      game_type == 'HC - Hardpoint' ~ 'Hardpoint',
      game_type == 'HC - Domination' ~ 'Domination'
    )
  ) %>%
  # separate map vote column. The larget number is always written first 
  separate(map_vote, into = c('winning_map_vote', 'losing_map_vote'), sep = ' to ', extra = 'merge', convert = TRUE)

# make sure the name of every map is cleaned for all 3 map columns. (set diff is NA only for missing maps)
setdiff(clean_data$map1, map_data$Name)
setdiff(clean_data$map2, map_data$Name)
setdiff(clean_data$choice, map_data$Name)

```

## Task 1

Research Question: Which maps are the most likely to win the map vote when they are an option?

To answer this question, we will need the 5 variables `map1`, `map2`, `winning_map_vote`, `losing_map_vote` and `choice` . For each map, we want to record the number of times it was entered into the vote and then calculate the number of times it was chosen for `choice` to calculate the probability. 

Then, after calculating the probabilities of each map, we can make a ggplot visualization to display the results.

```{r}
map_vote_data <- clean_data %>%
  select(map1, map2, winning_map_vote, losing_map_vote, choice)
```
The dataset looks good by inspection, except for one strange value in the 489th observation where both `map1` and `map2` have the same number of votes, but `choice` is set to `map2`. We can fix this by changing the map choice to be the first map. Now we are ready to answer the research question.

```{r}
map_vote_data[489,]$choice <- map_vote_data[489,]$map1
```


To answer this question an ideal dataset would have the following columns: `map`, `win`, `method`. We create two data frames that contain map and winning statistics for the two maps: the first one using only the `map1` column as the map and the second one only using the `map2` column as the map. We call them `m1_stats` and `m2_stats` respectively and concatenate the data frames. Then we have all voting results of the two maps for all the games in a tidy format. Finally, we can use grouping to calculate the statistics for a given map. 

We run into another issue of only 1 of either `map1` or `map2` having data while the other is missing. For some of the cases, we can remedy this by checking against the `choice` column. We do this for both the `map1` and `map2` columns for `map_vote_data`. 

```{r}
# we filter here to show the few cases where this happens. in the next code chunk,
# we clean the data to a consistent format.
map_vote_data %>%
  filter(
    is.na(map1) & !is.na(map2) | is.na(map2) & !is.na(map1)
  )
```

There are a few cases that we work through to fix this issue. If one column is the same as the choice and the other column is missing, there isnt much that can be done. If the choice is unknown, then we also cannot do much. Finally, if one of the columns exist and is not the same as choice, then the other column has to be the choice. 
```{r}
map_vote_data <- map_vote_data %>%
  mutate(
    # since we only have a few specific cases, we can 'hard-code' them into 
    # the data wrangling
    map1 = if_else(map2 != choice, choice, map1),
    map2 = if_else(map1 != choice, choice, map2),
    choice = if_else(map2 == choice & is.na(map1), NA, choice)
  )

# start creating the dataframes that are used for this question
m1_stats <- map_vote_data %>%
  select(-map2) %>%
  subset(!is.na(map1)) %>%
  group_by(map1) %>%
  reframe(
    win = (map1 == choice),
    # there are 3 cases for the method: either a map lost, won by votes, or got forced to win because it was map1
    method = case_when(
    map1 != choice ~ 'Did Not Win',
    map1 == choice & winning_map_vote > losing_map_vote ~ 'Voted',
    map1 == choice & winning_map_vote == losing_map_vote ~ 'Forced'
    )
  ) %>%
  rename(
    map = map1
  )

m2_stats <- map_vote_data %>%
  select(-map1) %>%
  subset(!is.na(map2)) %>%
  group_by(map2) %>%
  reframe(
    win = map2 == choice,
    # there are 2 cases for map2: either it lost or it won by votes. it is never forced to be the map.
    method = case_when(
    map2 == choice & winning_map_vote > losing_map_vote ~ 'Voted',
    !(map2 == choice & winning_map_vote > losing_map_vote) ~ 'Did Not Win' # if it was not voted, then it did not win
    )
  ) %>%
  rename(
    map = map2
  )

map_stats <- rbind(m1_stats, m2_stats)

# make sure map_stats does not have any NA values, if so, figure out why
sum(is.na(m1_stats))
sum(is.na(m2_stats))
sum(is.na(map_stats))
```

Finally, we use our new data frame `map_stats` to answer the question and make the visualization. This data frame contains only matches in which all map related columns are not missing (times 2; one for each map). If we want to answer what maps are the most likely to win a vote when they are chosen, we should get the probabilities that they win given that they are chosen and sort them by map. What we can do is get the probability of win for a single game by doing win/times the map was chosen which will calculate the probability of winning that singlee instance. Then we can ungroup the data before grouping by both map and the method of winning to get probabilities for each combination of map/method. 

```{r}
map_probs <- map_stats %>%
  group_by(map) %>%
  mutate(
    times_chosen = n(),
    prob_win = win/times_chosen
  ) %>% 
  ungroup() %>%
  group_by(map, method) %>%
  summarize(
    total_prob = sum(prob_win)
  ) %>% 
  group_by(map) %>%
  mutate(
    total_sum = sum(total_prob)
    ) %>%
  ungroup() %>%
  mutate(map = reorder(map, total_sum))
map_probs
```

We can interpret the table above like so: When a map, say 'Amerika', was up for vote, it was chosen to be the game map 48% of the time, forced to be the map 3% of the time, and lost the other 49%, although the loss percentage is not explicitly reported in the table. 

```{r}
# making the plot
ggplot(map_probs, aes(x = map, y = total_prob, fill = method)) + 
  geom_bar(stat = 'identity') + 
  labs(
    x = 'Map', 
    y = 'Total Probability',
    fill = 'Method of Win',
    title = 'Total Probability of a Map To Be Chosen When it Appears For the Map Vote'
    ) + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

TODO: x,y,z are the most common maps. draw data and insights from summary table